<a id="rocket" href="#top" class="show"></a><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description"/><title>REST API与云计算 | Tom Talk</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/pure-min.css"/><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"/><link rel="stylesheet" type="text/css" href="/css/style.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="apple-touch-icon" href="/apple-touch-icon.png"/><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">REST API与云计算</h1><a id="logo" href="/">Tom Talk</a><p class="description">分享我的实践、思考、积累</p></div><div id="nav-menu"><a href="/" class="current"><i class="icon-home"> 首页</i></a><a href="/archives/"><i class="icon-archive"> 归档</i></a><a href="/about/"><i class="icon-about"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">REST API与云计算</h1><div class="post-meta">2016-04-11 | </div><span data-thread-key="/2016/04/11/rest-api.html" class="ds-thread-count"></span><div class="post-content"><p>云计算时代就是将各种各样的能力(比如Iaas、Sass、Paas)服务化，服务化的一个很基本也很关键的部分工作是设计合理的REST API接口暴露各种各样的服务，自动化API接口互相结合爆发出了各种各样的连锁反应，使得云计算如大爆炸般蔓延到信息时代的各个角落。</p>
<p>REST API设计的资料很多，比如这个 <a href="https://github.com/aisuhua/restful-api-design-references" target="_blank" rel="external">git rep</a> 总结了很多REST API design的基本设计参考文献。</p>
<p>偶遇微信技术公众号@程序人生《撰写合格的REST API》一文，感叹其总结得如此恰到好处，在这个做下简单总结和转载。</p>
<h3 id="1_RFC一致性">1 RFC一致性</h3><p>REST API一般用来将某种资源和允许的对资源的操作暴露给外界，使调用者能够以正确的方式操作资源。这里，在输入输出的处理上，要符合HTTP/1.1（不久的将来，要符合HTTP/2.0）的RFC，保证接口的一致性。这里主要讲输入的method/headers和输出的status code。</p>
<h4 id="1-1_Methods">1.1 Methods</h4><p>HTTP协议提供了很多methods来操作数据：</p>
<ul>
<li><p>GET: 获取某个资源，GET操作应该是幂等（idempotence）的，且无副作用。</p>
</li>
<li><p>POST: 创建一个新的资源。</p>
</li>
<li><p>PUT: 替换某个已有的资源。PUT操作虽然有副作用，但其应该是幂等的。</p>
</li>
<li><p>PATCH（RFC5789）: 修改某个已有的资源。</p>
</li>
<li><p>DELETE：删除某个资源。DELETE操作有副作用，但也是幂等的。</p>
</li>
</ul>
<p>幂等在HTTP/1.1中定义如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Methods can also have <span class="keyword">the</span> <span class="keyword">property</span> <span class="keyword">of</span> <span class="string">"idempotence"</span> <span class="keyword">in</span> <span class="keyword">that</span> (<span class="keyword">aside from</span> <span class="keyword">error</span> <span class="keyword">or</span> expiration issues) <span class="keyword">the</span> side-effects <span class="keyword">of</span> N &gt; <span class="number">0</span> identical requests <span class="keyword">is</span> <span class="keyword">the</span> same <span class="keyword">as</span> <span class="keyword">for</span> a single request. 如今鲜有人在撰写REST API时，</span><br><span class="line"></span><br><span class="line">简单说来就是一个操作符合幂等性，那么相同的数据和参数下，执行一次或多次产生的效果（副作用）是一样的。</span><br></pre></td></tr></table></figure>
<p>现在大多的REST framwork对HTTP methods都有正确的支持，有些旧的framework可能未必对PATCH有支持，需要注意。如果自己手写REST API，一定要注意区分POST/PUT/PATCH/DELETE的应用场景。</p>
<h4 id="1-2_Headers">1.2 Headers</h4><p>很多REST API犯的比较大的一个问题是：不怎么理会request headers。对于REST API，有一些HTTP headers很重要：</p>
<ul>
<li><p>Accept：服务器需要返回什么样的content。如果客户端要求返回”application/xml”，服务器端只能返回”application/json”，那么最好返回status code 406 not acceptable（RFC2616），当然，返回application/json也并不违背RFC的定义。一个合格的REST API需要根据Accept头来灵活返回合适的数据。</p>
</li>
<li><p>If-Modified-Since/If-None-Match：如果客户端提供某个条件，那么当这条件满足时，才返回数据，否则返回304 not modified。比如客户端已经缓存了某个数据，它只是想看看有没有新的数据时，会用这两个header之一，服务器如果不理不睬，依旧做足全套功课，返回200 ok，那就既不专业，也不高效了。</p>
</li>
<li><p>If-Match：在对某个资源做PUT/PATCH/DELETE操作时，服务器应该要求客户端提供If-Match头，只有客户端提供的Etag与服务器对应资源的Etag一致，才进行操作，否则返回412 precondition failed。这个头非常重要，下文详解。</p>
</li>
</ul>
<h4 id="1-3_Status_Code">1.3 Status Code</h4><p>很多REST API犯下的另一个错误是：返回数据时不遵循RFC定义的status code，而是一律200 ok + error message。这么做在client + API都是同一公司所为还凑合可用，但一旦把API暴露给第三方，不但贻笑大方，还会留下诸多互操作上的隐患。</p>
<p>以上仅仅是最基本的一些考虑，要做到完全符合RFC，除了参考RFC本身以外，erlang社区的webmachine或者clojure下的liberator都是不错的实现，是目前为数不多的REST API done right的library/framework。</p>
<p><img src="http://nos.netease.com/doc/jcs" alt="1"></p>
<p>（liberator的decision tree，沿袭了webmachine的思想，svg高清图详见<a href="https://clojure-liberator.github.io/liberator/assets/img/decision-graph.svg" target="_blank" rel="external">decision-graph</a>）</p>
<h3 id="2_安全性">2 安全性</h3><p>前面说过，REST API承前启后，是系统暴露给外界的接口，所以，其安全性非常重要。安全并单单不意味着加密解密，而是一致性（integrity），机密性（confidentiality）和可用性（availibility）。</p>
<h4 id="2-1_请求数据验证">2.1 请求数据验证</h4><p>我们从数据流入REST API的第一步 —— 请求数据的验证 —— 来保证安全性。你可以把请求数据验证看成一个巨大的漏斗，把不必要的访问统统过滤在第一线：</p>
<p>Request headers是否合法：如果出现了某些不该有的头，或者某些必须包含的头没有出现或者内容不合法，根据其错误类型一律返回4xx。比如说你的API需要某个特殊的私有头（e.g. X-Request-ID），那么凡是没有这个头的请求一律拒绝。这可以防止各类漫无目的的webot或crawler的请求，节省服务器的开销。</p>
<p>Request URI和Request body是否合法：如果请求带有了不该有的数据，或者某些必须包含的数据没有出现或内容不合法，一律返回4xx。比如说，API只允许querystring中含有query，那么”?sort=desc”这样的请求需要直接被拒绝。有不少攻击会在querystring和request body里做文章，最好的对应策略是，过滤所有含有不该出现的数据的请求。</p>
<h4 id="2-2_数据完整性验证">2.2 数据完整性验证</h4><p>REST API往往需要对backend的数据进行修改。修改是个很可怕的操作，我们既要保证正常的服务请求能够正确处理，还需要防止各种潜在的攻击，如replay。数据完整性验证的底线是：保证要修改的数据和服务器里的数据是一致的 —— 这是通过Etag来完成。</p>
<p>Etag可以认为是某个资源的一个唯一的版本号。当客户端请求某个资源时，该资源的Etag一同被返回，而当客户端需要修改该资源时，需要通过”If-Match”头来提供这个Etag。服务器检查客户端提供的Etag是否和服务器同一资源的Etag相同，如果相同，才进行修改，否则返回412 precondition failed。</p>
<p>使用Etag可以防止错误更新。比如A拿到了Resource X的Etag X1，B也拿到了Resource X的Etag X1。B对X做了修改，修改后系统生成的新的Etag是X2。这时A也想更新X，由于A持有旧的Etag，服务器拒绝更新，直至A重新获取了X后才能正常更新。</p>
<p>Etag类似一把锁，是数据完整性的最重要的一道保障。Etag能把绝大多数integrity的问题扼杀在摇篮中，当然，race condition还是存在的：如果B的修改还未进入数据库，而A的修改请求正好通过了Etag的验证时，依然存在一致性问题。这就需要在数据库写入时做一致性写入的前置检查。</p>
<h4 id="2-3_访问控制">2.3 访问控制</h4><p>REST API需要清晰定义哪些操作能够公开访问，哪些操作需要授权访问。一般而言，如果对REST API的安全性要求比较高，那么，所有的API的所有操作均需得到授权。</p>
<p>在HTTP协议之上处理授权有很多方法，如HTTP BASIC Auth，OAuth，HMAC Auth等，其核心思想都是验证某个请求是由一个合法的请求者发起。Basic Auth会把用户的密码暴露在网络之中，并非最安全的解决方案，OAuth的核心部分与HMAC Auth差不多，只不过多了很多与token分发相关的内容。这里我们主要讲讲HMAC Auth的思想。</p>
<p>回到Security的三个属性：一致性，机密性，和可用性。HMAC Auth保证一致性：请求的数据在传输过程中未被修改，因此可以安全地用于验证请求的合法性。</p>
<p>HMAC主要在请求头中使用两个字段：Authorization和Date（或X-Auth-Timestamp）。Authorization字段的内容由”:”分隔成两部分，”:”前是access-key，”:”后是HTTP请求的HMAC值。在API授权的时候一般会为调用者生成access-key和access-secret，前者可以暴露在网络中，后者必须安全保存。当客户端调用API时，用自己的access-secret按照要求对request的headers/body计算HMAC，然后把自己的access-key和HMAC填入Authorization头中。服务器拿到这个头，从数据库（或者缓存）中取出access-key对应的secret，按照相同的方式计算HMAC，如果其与Authorization header中的一致，则请求是合法的，且未被修改过的；否则不合法。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="request">GET <span class="string">/photos/puppy.jpg</span> HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span>: <span class="string">johnsmith.s3.amazonaws.com</span></span><br><span class="line"><span class="attribute">Date</span>: <span class="string">Mon, 26 Mar 2007 19:37:58 +0000</span></span><br><span class="line"></span><br><span class="line"><span class="ruby"><span class="constant">Authorization</span><span class="symbol">:</span> <span class="constant">AWS</span> <span class="constant">AKIAIOSFODNN7EXAMPLE</span><span class="symbol">:frJIUN8DYpKDtOLCwo//yllqDzg=</span></span></span><br></pre></td></tr></table></figure>
<p><img src="http://nos.netease.com/doc/aws-hmac" alt=""></p>
<p>在做HMAC的时候，request headers中的request method，request URI，Date/X-Auth-Timestamp等header会被计算在HMAC中。将时间戳计算在HMAC中的好处是可以防止replay攻击。客户端和服务器之间的UTC时间正常来说偏差很小，那么，一个请求携带的时间戳，和该请求到达服务器时服务器的时间戳，中间差别太大，超过某个阈值（比如说120s），那么可以认为是replay，服务器主动丢弃该请求。</p>
<p>使用HMAC可以很大程度上防止DOS攻击 —— 无效的请求在验证HMAC阶段就被丢弃，最大程度保护服务器的计算资源。</p>
<h4 id="2-4_请求数据验证">2.4 请求数据验证</h4><p>HMAC Auth尽管在保证请求的一致性上非常安全，可以用于鉴别请求是否由合法的请求者发起，但请求的数据和服务器返回的响应都是明文传输，对某些要求比较高的API来说，安全级别还不够。这时候，需要部署HTTPS。在其之上再加一层屏障。</p>
<h4 id="3_其它">3  其它</h4><p>做到了接口一致性（符合RFC）和安全性，REST API可以算得上是合格了。当然，一个实现良好的REST API还应该有如下功能：</p>
<ul>
<li><p>rate limiting：访问限制。</p>
</li>
<li><p>metrics：服务器应该收集每个请求的访问时间，到达时间，处理时间，latency，便于了解API的性能和客户端的访问分布，以便更好地优化性能和应对突发请求。</p>
</li>
<li><p>docs：丰富的接口文档 - API的调用者需要详尽的文档来正确调用API，可以用swagger来实现。</p>
</li>
<li><p>hooks/event propogation：其他系统能够比较方便地与该API集成。比如说添加了某资源后，通过kafka或者rabbitMQ向外界暴露某个消息，相应的subscribers可以进行必要的处理。不过要注意的是，hooks/event propogation可能会破坏REST API的幂等性，需要小心使用。</p>
</li>
</ul>
<p>各个社区里面比较成熟的REST API framework/library：</p>
<ul>
<li><p>Python: django-rest-framework（django），eve（flask）。各有千秋。可惜python没有好的类似webmachine的实现。</p>
</li>
<li><p>Erlang/Elixir: webmachine/ewebmachine。</p>
</li>
<li><p>Ruby: webmachine-ruby。</p>
</li>
<li><p>Clojure：liberator。</p>
</li>
</ul>
<p>其它语言接触不多，就不介绍了。可以通过访问该语言在github上相应的awesome repo（google awesome XXX，如awesome python），查看REST API相关的部分。</p>
</div><div class="tags"><a href="/tags/HTTP-API/">HTTP API</a><a href="/tags/REST/">REST</a></div><div class="post-nav"><a href="/2016/04/22/ProgrammingLanguages-GarbageCollection.html" class="pre"><i class="icon-previous">Garbage Collection</i></a><a href="/2016/03/11/x-forwarded-for.html" class="next">HTTP之X-Forwarded-For<i class="icon-next"></i></a></div><div data-thread-key="/2016/04/11/rest-api.html" data-title="REST API与云计算" data-url="http://yoursite.com//2016/04/11/rest-api.html" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="/2016/04/11/rest-api.html" data-title="REST API与云计算" data-url="http://yoursite.com//2016/04/11/rest-api.html" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div id="search"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><input type="hidden" name="sitesearch" value="http://yoursite.com"></form></div></div><div class="widget"><div class="widget-title">分类</div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/code/">code</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title">标签</div><div class="tagcloud"><a href="/tags/云存储/" style="font-size: 15px;">云存储</a> <a href="/tags/GC/" style="font-size: 15px;">GC</a> <a href="/tags/HTTP-API/" style="font-size: 15px;">HTTP API</a> <a href="/tags/REST/" style="font-size: 15px;">REST</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/tags/Murphy-s-law/" style="font-size: 15px;">Murphy's law</a> <a href="/tags/分布式/" style="font-size: 15px;">分布式</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/浪漫/" style="font-size: 15px;">浪漫</a> <a href="/tags/古典/" style="font-size: 15px;">古典</a> <a href="/tags/Pragraming-Languages/" style="font-size: 15px;">Pragraming Languages</a> <a href="/tags/CDN/" style="font-size: 15px;">CDN</a> <a href="/tags/交流/" style="font-size: 15px;">交流</a> <a href="/tags/云存储、cdn/" style="font-size: 15px;">云存储、cdn</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/runtime/" style="font-size: 15px;">runtime</a> <a href="/tags/performance/" style="font-size: 15px;">performance</a> <a href="/tags/goroutine/" style="font-size: 15px;">goroutine</a> <a href="/tags/storage/" style="font-size: 15px;">storage</a> <a href="/tags/consistency/" style="font-size: 15px;">consistency</a> <a href="/tags/avaliable/" style="font-size: 15px;">avaliable</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a></div></div><div class="widget"><div class="widget-title">最新文章</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/04/22/ProgrammingLanguages-GarbageCollection.html">Garbage Collection</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/11/rest-api.html">REST API与云计算</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/11/x-forwarded-for.html">HTTP之X-Forwarded-For</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/01/gopherchina2016.html">GopherChina2016</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/28/The-Murphy-s-law.html">墨菲定律(The-Murphy's-law)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/24/shikong.html">生命的群体效应 -《失控》</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/code.html">一道笔试题</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/08/Zen-and-the-Art-of-Motorcycle-Maintenance.html">Zen and the Art of Motorcycle Maintenance</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/09/facebook_photo_caching.html">Facebook图片服务堆栈浅析</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/09/23/youpai_communicate.html">又拍云交流</a></li></ul></div><div class="widget"><div class="comments-title">最近评论</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">友情链接</div><ul></ul><a href="http://andremouche.github.io/" title="Shirly-blog" target="_blank">Shirly-blog</a></div></div></div></div><div id="footer">© <a href="/" rel="nofollow">Tom Talk.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></body><script src="/js/jquery.min.js" type="text/javascript"></script>
<script src="/js/totop.js" type="text/javascript"></script><script src="/js/fancybox.pack.js" type="text/javascript"></script><link rel="stylesheet" href="/css/jquery.fancybox.css" type="text/css"><script>$(document).ready(function() {
  $('img').each(function() {
    if ($(this).parent().hasClass('fancybox')) return;
    if ($(this).hasClass('nofancybox')) return;
    var alt = this.alt;
    if (alt) $(this).after('<span class="caption">' + alt + '</span>');
    $(this).wrap('<a href="' + ($(this).attr('data-src') == null ? this.src : $(this).attr('data-src')) + '" title="' + alt + '" class="fancybox"></a>');
  });
  $(this).find('.fancybox').each(function(){
    $(this).attr('rel', 'article');
  });
});</script><script>$(document).ready(function() {
  $("a[href$='.jpg'],a[href$='.png'],a[href$='.gif']").attr('rel', 'gallery').fancybox({
   helpers : {
   title: { type: 'inside'}
   }
 });
});
</script><script>var duoshuoQuery = {short_name:'workjlsunduoshuo'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></html>